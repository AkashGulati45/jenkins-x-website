<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X â€“ Overview</title>
    <link>/docs/contributing/addons/</link>
    <description>Recent content in Overview on Jenkins X</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/contributing/addons/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Binary Plugins for the Jenkins X CLI</title>
      <link>/docs/contributing/addons/plugins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/contributing/addons/plugins/</guid>
      <description>
        
        
        

&lt;p&gt;This guide shows you how to write plugins for the &lt;code&gt;jx&lt;/code&gt; CLI. Plugins extend the &lt;code&gt;jx&lt;/code&gt; CLI with new sub-commands allowing for new
features not included in Jenkins X. &lt;code&gt;jx&lt;/code&gt; plugins can be managed by Jenkins X meaning neither the plugin developer nor
the plugin user has to worry about how to install the plugin onto the user&amp;rsquo;s computer.&lt;/p&gt;

&lt;p&gt;You might want to write a plugin for the &lt;code&gt;jx&lt;/code&gt; CLI if you developed some new functionality for Jenkins X and wanted to provide a
way for the user to easily interact with it via the &lt;code&gt;jx&lt;/code&gt; CLI rather than make them install a new CLI. This could be particularly
useful inside a pipeline step.&lt;/p&gt;

&lt;h2 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h2&gt;

&lt;p&gt;You need to have a working &lt;code&gt;jx&lt;/code&gt; binary installed, one newer than around &lt;code&gt;v1.3.600&lt;/code&gt;. You need to have Go installed.&lt;/p&gt;

&lt;h2 id=&#34;writing-jenkins-x-cli-plugins&#34;&gt;Writing Jenkins X CLI plugins&lt;/h2&gt;

&lt;p&gt;You can write a plugin in any programming language or script that allows you to write command-line commands.&lt;/p&gt;

&lt;p&gt;There is no plugin installation or pre-loading required. Plugin executables receive the inherited environment from the
 &lt;code&gt;jx&lt;/code&gt; binary.&lt;/p&gt;

&lt;h3 id=&#34;example-plugin&#34;&gt;Example plugin&lt;/h3&gt;

&lt;p&gt;Here is a simple plugin that simply outputs a log statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	fmt.Println(&amp;quot;Have some tasty brie.&amp;quot;)
	os.Exit(0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We strongly recommend using Go and the &lt;a href=&#34;https://github.com/spf13/cobra&#34; target=&#34;_blank&#34;&gt;Cobra CLI framework&lt;/a&gt;. This allows you to easily
build a well structured plugin with subcommands and argument handling.&lt;/p&gt;

&lt;p&gt;We &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/2832&#34; target=&#34;_blank&#34;&gt;plan&lt;/a&gt; to build a quickstart and build pack that allows you to
quickly create a new Cobra based plugin.&lt;/p&gt;

&lt;h3 id=&#34;using-the-plugin&#34;&gt;Using the plugin&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Build a binary&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-$&#34;&gt;2. Add it to your path

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$ sudo mv ./jx-brie /usr/local/bin```&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can now use the plugin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jx brie
Have some tasty brie
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;plugin-management&#34;&gt;Plugin Management&lt;/h2&gt;

&lt;p&gt;Whilst being able to run a plugin is useful you&amp;rsquo;ll normally want to make it available to everyone who uses your Jenkins X cluster.&lt;/p&gt;

&lt;p&gt;Jenkins X provides binary plugin management via the &lt;code&gt;plugin&lt;/code&gt; custom resource.&lt;/p&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;distributing-your-plugin-using-apps&#34;&gt;Distributing your plugin using Apps&lt;/h2&gt;

&lt;p&gt;Now that you&amp;rsquo;ve written your plugin you&amp;rsquo;ll want to distribute it.&lt;/p&gt;

&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Worked Example</title>
      <link>/docs/contributing/addons/worked-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/contributing/addons/worked-example/</guid>
      <description>
        
        
        

&lt;p&gt;In this worked example we will implement the functionality of the classic &lt;a href=&#34;https://wiki.jenkins.io/display/JENKINS/JUnit+Plugin&#34; target=&#34;_blank&#34;&gt;JUnit Plugin&lt;/a&gt; from Jenkins in Jenkins X as a series of extensions to Jenkins X.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This guide is still a work in progress!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;functional-requirements&#34;&gt;Functional Requirements&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Collect JUnit XML files from build&lt;/li&gt;
&lt;li&gt;Associate with pipeline / pipeline step execution&lt;/li&gt;
&lt;li&gt;Notify user of URL to view test results&lt;/li&gt;
&lt;li&gt;Provide historical/trend view of tests&lt;/li&gt;
&lt;li&gt;Allow test results to affect build health&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A working installation of &lt;code&gt;jx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A working Jenkins X cluster&lt;/li&gt;
&lt;li&gt;A working local install of Java and Maven&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;collect-junit-xml-files-from-build&#34;&gt;Collect JUnit XML files from build&lt;/h2&gt;

&lt;h3 id=&#34;create-a-sample-project&#34;&gt;Create a sample project&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll start by creating a sample Java project which will run some tests.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Run &lt;code&gt;jx create quickstart -f spring-boot-web&lt;/code&gt;. You can accept the defaults when prompted.&lt;/li&gt;
&lt;li&gt;Import the created sources into your favorite IDE.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open &lt;code&gt;pom.xml&lt;/code&gt; and add JUnit as a dependency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create the file &lt;code&gt;src/test/java/jenkinsx/example/springboot/WelcomeControllerTest.java&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy and paste this code into the &lt;code&gt;WelcomeControllerTest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jenkinsx.example.springboot;

import org.junit.Assert;
import org.junit.Test;

import java.util.HashMap;
import java.util.Map;

public class WelcomeControllerTest {

    @Test
    public void testWelcome() {
        WelcomeController wc = new WelcomeController();
        Map&amp;lt;String, Object&amp;gt; res = new HashMap&amp;lt;String, Object&amp;gt;();
        wc.welcome(res);
        Assert.assertEquals(res.get(&amp;quot;message&amp;quot;), &amp;quot;Hello World&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Validate your changes by running &lt;code&gt;mvn test&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Commit your changes and make sure the app makes it to staging in Jenkins X.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Our test reports will be generated in Jenkins X build pods, so we want to use that for development. Jenkins X DevPods make that easy. Run &lt;code&gt;jx create devpod --sync&lt;/code&gt; in your project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Validate the DevPod is working by running &lt;code&gt;mvn test&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;generate-a-human-readable-report&#34;&gt;Generate a Human Readable Report&lt;/h3&gt;

&lt;p&gt;By default Maven Surefire doesn&amp;rsquo;t generate HTML files, just XML reports. We want people to be able to look at the reports, as well as be able to submit the XML for analysis.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;In the DevPod run &lt;code&gt;mvn install surefire-report:report&lt;/code&gt;. Validate that &lt;code&gt;target/site/surefire-report.html&lt;/code&gt; is generated.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a script &lt;code&gt;junit.sh&lt;/code&gt; in the sample project with this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# Generate the HTML report
mvn surefire-report:report
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;store-the-reports&#34;&gt;Store the reports&lt;/h3&gt;

&lt;p&gt;We need a place to store the reports. A simple Go program will suffice for now.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Run &lt;code&gt;jx create quickstart -f spring-boot-web&lt;/code&gt;. You can accept the defaults when prompted.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Replace the &lt;code&gt;main.go&lt;/code&gt; contents with this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;io/ioutil&amp;quot;
  &amp;quot;log&amp;quot;
  &amp;quot;net/http&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;path/filepath&amp;quot;
)

const maxUploadSize = 2 * 1024 * 1024 // 2 MB
const uploadPath = &amp;quot;/reports&amp;quot;
const downloadPort = 8080
const uploadPort = 8081
const bind = &amp;quot;0.0.0.0&amp;quot;

func main() {
  go uploadServer()
  downloadServer()
}

func downloadServer() {
  server:= http.NewServeMux()
  server.Handle(&amp;quot;/&amp;quot;, http.FileServer(http.Dir(uploadPath)))
  log.Printf(&amp;quot;Download server listening on %s:%d\n&amp;quot;, bind, downloadPort)
  http.ListenAndServe(fmt.Sprintf(&amp;quot;%s:%d&amp;quot;, bind, downloadPort), server)
}

func uploadServer() {
  server:= http.NewServeMux()
  server.HandleFunc(&amp;quot;/&amp;quot;, uploadFileHandler())
  log.Printf(&amp;quot;Upload server listening on %s:%d\n&amp;quot;, bind, uploadPort)
  http.ListenAndServe(fmt.Sprintf(&amp;quot;%s:%d&amp;quot;, bind, uploadPort), server)
}

func uploadFileHandler() http.HandlerFunc {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // validate file size
    r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize)
    if err := r.ParseMultipartForm(maxUploadSize); err != nil {
      log.Println(err)
      renderError(w, &amp;quot;FILE_TOO_BIG&amp;quot;, http.StatusBadRequest)
      log.Println(err)
      return
    }

    // parse and validate file and post parameters
    file, _, err := r.FormFile(&amp;quot;upload&amp;quot;)
    if err != nil {
      renderError(w, &amp;quot;INVALID_FILE&amp;quot;, http.StatusBadRequest)
      log.Println(err)
      return
    }
    defer file.Close()
    fileBytes, err := ioutil.ReadAll(file)
    if err != nil {
      renderError(w, &amp;quot;INVALID_FILE&amp;quot;, http.StatusBadRequest)
      log.Println(err)
      return
    }
    filename, dir := filepath.Split(r.URL.Path)
    newPath := filepath.Join(dir, filename)

    err = os.MkdirAll(dir, os.FileMode(0755))
    if err != nil {
      renderError(w, &amp;quot;CANT_CREATE_DIR&amp;quot;, http.StatusInternalServerError)
      log.Println(err)
      return
    }
    // write file
    newFile, err := os.Create(newPath)
    if err != nil {
      renderError(w, &amp;quot;CANT_WRITE_FILE&amp;quot;, http.StatusInternalServerError)
      log.Println(err)
      return
    }
    defer newFile.Close() // idempotent, okay to call twice
    if _, err := newFile.Write(fileBytes); err != nil || newFile.Close() != nil {
      renderError(w, &amp;quot;CANT_WRITE_FILE&amp;quot;, http.StatusInternalServerError)
      log.Println(err)
      return
    }
    w.Write([]byte(&amp;quot;SUCCESS&amp;quot;))
  })
}

func renderError(w http.ResponseWriter, message string, statusCode int) {
  w.WriteHeader(http.StatusBadRequest)
  w.Write([]byte(message))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will create an HTTP server that listens on two ports. It listens on 8080 to serve files from the &lt;code&gt;/reports&lt;/code&gt; directory, and listens on 8081 for file uploads (using the URL path as the path as the location under &lt;code&gt;/reports&lt;/code&gt; to store the file). By listening on different ports for download and upload we can easily expose the downloads service outside the cluster, but restrict the uploads service to inside the cluster meaning we have no need to secure the transport.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll add authentication to the upload endpoint at a later point.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We need to store the reports somewhere, and in Kubernetes this means using a volume. Add this snippet to the bottom of &lt;code&gt;charts/jenkins-x-reports/templates/deployment.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;      volumes:
      - name: {{ .Values.service.reportVolumeName }}
        emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and add this snippet to the container (just below above &lt;code&gt;ports&lt;/code&gt; will work well):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;        volumeMounts:
        - name: {{ .Values.service.reportVolumeName }}
          mountPath: {{ .Values.service.reportMountPath }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now modify &lt;code&gt;charts/jenkins-x-reports/values.yaml&lt;/code&gt; and modify the &lt;code&gt;service&lt;/code&gt; and add (just after &lt;code&gt;internalPort&lt;/code&gt; will work well):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  reportVolumeName: reports-volume
  reportMountPath: /reports
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice that we&amp;rsquo;ve used &lt;code&gt;emptyDir{}&lt;/code&gt; to store the reports - this is transient and reports will be lost when the pod dies. We&amp;rsquo;ll replace this with a persistent volume later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modify the &lt;code&gt;Dockerfile&lt;/code&gt; to expose port &lt;code&gt;8081&lt;/code&gt; as well by adding the line &lt;code&gt;EXPOSE 8081&lt;/code&gt; just after &lt;code&gt;EXPOSE 8080&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modify &lt;code&gt;charts/jenkins-x-reports/values.yaml&lt;/code&gt; and add the values for the upload service just after the existing service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;serviceUpload:
  name: jenkins-x-reports-upload
  type: ClusterIP
  externalPort: 80
  internalPort: 8081
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we&amp;rsquo;ve given it a unique name, set the internal port correctly and removed the annotations that instruct Jenkins X to expose the service outside the cluster.&lt;/p&gt;

&lt;p&gt;We now need to create a template for these values. Add the file &lt;code&gt;charts/jenkins-x-reports/templates/service-upload.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  apiVersion: v1
  kind: Service
  metadata:
  {{- if .Values.serviceUpload.name }}
    name: {{ .Values.serviceUpload.name }}
  {{- else }}
    name: {{ template &amp;quot;fullname&amp;quot; . }}
  {{- end }}
    labels:
      chart: &amp;quot;{{ .Chart.Name }}-{{ .Chart.Version | replace &amp;quot;+&amp;quot; &amp;quot;_&amp;quot; }}&amp;quot;
  {{- if .Values.serviceUpload.annotations }}
    annotations:
  {{ toYaml .Values.serviceUpload.annotations | indent 4 }}
  {{- end }}
  spec:
    type: {{ .Values.serviceUpload.type }}
    ports:
    - port: {{ .Values.serviceUpload.externalPort }}
      targetPort: {{ .Values.serviceUpload.internalPort }}
      protocol: TCP
      name: http
    selector:
      app: {{ template &amp;quot;fullname&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file is simply a copy of &lt;code&gt;service.yaml&lt;/code&gt; with the &lt;code&gt;service&lt;/code&gt; variable changed to &lt;code&gt;serviceUpload&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We also need to add the upload port to the list of container ports. Just below &lt;code&gt;containerPort: {{ .Values.service.internalPort }}&lt;/code&gt; add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;          containerPort: {{ .Values.serviceUpload.internalPort }}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run this as an app on your Jenkins X cluster by pushing your code changes to GitHub. The app will build and can be tested in the staging environment.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Validate you can upload and download files. In the DevPod for the sample app run &lt;code&gt;curl -F upload=@target/site/surefire-report.html http://jenkins-x-reports-upload.jx-staging/test/1&lt;/code&gt; and then validate that the file is there by running &lt;code&gt;curl http://jenkins-x-reports.jx-staging/test/1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Promote the app to production using &lt;code&gt;jx promote -a jenkins-x-reports -e production -v 0.0.1&lt;/code&gt; (assuming you are still on your first version of the app)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To POST all the JUnit artifacts to the reports server use this script&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

UPLOADED=uploaded.yaml
REPORT_HOST=`jx get urls -e production | grep -o http://jenkins-x-reports.jx-production.*`

function upload() {
    upload_junit_artifacts
}

function upload_junit_artifacts() {
    # Generate the HTML report
    mvn surefire-report:report
    upload_file target/site/surefire-report.html
    for f in target/surefire-reports/*.xml; do
        upload_file ${f}
    done
}

function upload_file() {
    [ -f &amp;quot;$1&amp;quot; ] || break
    filename=$(basename $1)
    path=$ORG/$APP_NAME/$VERSION/$filename
    set -x
    curl -s -F upload=@$1 http://jenkins-x-reports-upload.jx-production/$path
    set +x
    echo &amp;quot;    ${filename}: ${REPORT_HOST}/${path}&amp;quot; &amp;gt;&amp;gt; $UPLOADED
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make the script executable by running &lt;code&gt;chmod u+x junit.sh&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tell Jenkins to execute the script by adding this snippet to the &lt;code&gt;Jenkinsfile&lt;/code&gt; just above the &lt;code&gt;jx step post build&lt;/code&gt; lines in both the &lt;code&gt;CI Build and push snapshot&lt;/code&gt; and &lt;code&gt;Build Release&lt;/code&gt; stages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        sh &amp;quot;VERSION=`cat VERSION` ./junit.sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So far we&amp;rsquo;ve had to add a script to the sample and modify the &lt;code&gt;Jenkinsfile&lt;/code&gt; to run the script. Later in this tutorial we&amp;rsquo;ll implement this functionality as a cross-cutting concern and be able to remove this from the sample project. But for now let&amp;rsquo;s focus on the functionality we need.&lt;/p&gt;

&lt;h3 id=&#34;create-an-index-of-reports&#34;&gt;Create an index of reports&lt;/h3&gt;

&lt;p&gt;In order to provide the user with access to reports we need to create a central list. A Kubernetes &lt;code&gt;ConfigMap&lt;/code&gt; is a simple way to store this information. A config map does have some limitations (they aren&amp;rsquo;t ideal for large amounts of rapidly changing data) so we&amp;rsquo;ll come back at a later stage and provide a better solution, but for now it allows us to focus on the user functionality.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use one &lt;code&gt;ConfigMap&lt;/code&gt; per app, and we&amp;rsquo;ll use a standard naming pattern so that other tools can work out where the test report config map is for each app. We&amp;rsquo;ll store the config maps in the &lt;code&gt;jx&lt;/code&gt; namespace.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Update the &lt;code&gt;junit.sh&lt;/code&gt; script with these three functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
CM_NAME=$ORG-$APP_NAME-test-reports

function create_cm_if_needed() {
    if ! kubectl get cm $CM_NAME &amp;amp;&amp;gt; /dev/null; then
        echo &amp;quot;Creating ConfigMap $CM_NAME&amp;quot;
        kubectl create cm $CM_NAME
    fi
}

function init_patch() {
    rm -f $UPLOADED
    echo &amp;quot;data:&amp;quot; &amp;gt;&amp;gt; $UPLOADED
    echo &amp;quot;  $VERSION: |-&amp;quot; &amp;gt;&amp;gt; $UPLOADED
}

function update_cm() {
    set -x
    kubectl -v1 patch cm $CM_NAME --patch &amp;quot;$(cat $UPLOADED)&amp;quot;
    set +x
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And update the &lt;code&gt;upload()&lt;/code&gt; function to call these functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;function upload() {
    create_cm_if_needed
    init_patch
    upload_junit_artifacts
    update_cm
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;visualize-the-test-results&#34;&gt;Visualize the test results&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll use Kibana and ElasticSearch to create dashboards to visualize the test results.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Install ElasticSearch by running &lt;code&gt;helm install --name jenkins-x-reports-elasticsearch incubator/elasticsearch&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install Kibana by running &lt;code&gt;helm install stable/kibana --name=jenkins-x-reports-kibana --set service.annotations.&amp;quot;fabric8\.io/expose&amp;quot;=true --set files.&amp;quot;kibana\.yml&amp;quot;.&amp;quot;elasticsearch\.url&amp;quot;=http://jenkins-x-reports-elasticsearch-client:9200 --set  &amp;amp;&amp;amp; jx upgrade ingress&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The ingress upgrade will ask you a number of questions, and you can just accept the defaults. You can now access Kibana by running &lt;code&gt;jx get urls&lt;/code&gt; and copying the URL for &lt;code&gt;jenkins-x-reports-kibana&lt;/code&gt; into your browser.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a mapping for the JUnit XML format in Kibana by pasting this code into the Kibana console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;PUT tests 
{
    &amp;quot;mappings&amp;quot;: {
      &amp;quot;junit&amp;quot;: { 
        &amp;quot;properties&amp;quot;: { 
        &amp;quot;errors&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot; },
        &amp;quot;failures&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot; },
        &amp;quot;name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;noNamespaceSchemaLocation&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; },
        &amp;quot;skipped&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot; },
        &amp;quot;tests&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot; },
        &amp;quot;time&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;double&amp;quot; },
        &amp;quot;xsi&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; },
        &amp;quot;appName&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;org&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;version&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;timestamp&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot; }
      }
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An initial client for sending data to Kibana is available at (&lt;a href=&#34;https://github.com/pmuir/junit-runner&#34; target=&#34;_blank&#34;&gt;https://github.com/pmuir/junit-runner&lt;/a&gt;). Download it and get it building.
As we start to convert the functionality we&amp;rsquo;ve built so far to a Jenkins X extension, we&amp;rsquo;ll move the scripted code we&amp;rsquo;ve written so far into this Go program. For now, we can just use the current version.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add this function to &lt;code&gt;junit.sh&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
function dashboard() {
    curl https://github.com/pmuir/junit-runner/releases/download/v0.0.4/junit-runner &amp;gt; junit-runner
    chmod u+x junit-runner
    ./junit-runner
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and call it from &lt;code&gt;upload()&lt;/code&gt;. Push your changes to the sample repo and watch as Kibana starts to be populated with data.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;a-better-way-to-build-functionality&#34;&gt;A better way to build functionality&lt;/h3&gt;

&lt;p&gt;If you have built plugins for something like Jenkins or Eclipse, you will be used to building the functionality you need to run &amp;ldquo;in process&amp;rdquo; - inside the main process that the application is running (e.g. the Jenkins master). More recently a different approach to writing plugins has become more popular where you build the functionality as a separate process that is managed by the main process; this is the model used by VS Code for example. We would recommend using this approach in Jenkins X, and because Jenkins X is based on Kubernetes, that means using a separate container or Pod to build your functionality, and calling out to using REST APIs.&lt;/p&gt;

&lt;p&gt;In this case that means that it would be better to build the functionality we created in &lt;code&gt;junit-runner&lt;/code&gt; into a separate pod, rather than run it inside the build pod. As it so happens we already have a pod - the one we built to store and serve the test artifacts.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s open that project up, and move the code which transforms the JUnit XML and sends it to elastic search into it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Open the &lt;code&gt;main.go&lt;/code&gt; file and add this function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func toJson(json []byte) ([]byte, error) {
  m, err := mxj.NewMapJson(json)
  if err != nil {
    return nil, err
  }

  if err != nil {
    return nil, err
  }
  // Kibana is quite restrictive in the way it accepts JSON, so just rebuild the JSON entirely!

  utc, _ := time.LoadLocation(&amp;quot;UTC&amp;quot;)
  data := map[string]interface{} {
    &amp;quot;org&amp;quot;: os.Getenv(&amp;quot;ORG&amp;quot;),
    &amp;quot;appName&amp;quot;: os.Getenv(&amp;quot;APP_NAME&amp;quot;),
    &amp;quot;version&amp;quot;: os.Getenv(&amp;quot;VERSION&amp;quot;),
    &amp;quot;errors&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-errors&amp;quot;),
    &amp;quot;failures&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-failures&amp;quot;),
    &amp;quot;testsuiteName&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-name&amp;quot;),
    &amp;quot;skippedTests&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-skipped&amp;quot;),
    &amp;quot;tests&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-tests&amp;quot;),
    &amp;quot;time&amp;quot;: m.ValueOrEmptyForPathString(&amp;quot;testsuite.-time&amp;quot;),
    &amp;quot;timestamp&amp;quot;: time.Now().In(utc).Format(&amp;quot;2006-01-02T15:04:05Z&amp;quot;),
    // TODO Add the TestCases
  }
  fmt.Printf(&amp;quot;%s&amp;quot;, data)
  return json2.Marshal(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function comes directly from the &lt;code&gt;junit-runner&lt;/code&gt; code and is responsible for building a piece of JSON that is used by Kibana.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We also need to add this function from the &lt;code&gt;junit-runner&lt;/code&gt; code which reads the XML file, converts it to JSON using &lt;code&gt;toJson()&lt;/code&gt;, and then sends it onwards to our ElasticSearch instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func sendToElasticSearch(reader io.Reader, path string) error {
  _, json, err := x2j.XmlReaderToJson(reader)
  if err != nil {
    return err
  }
  json, err = toJson(json)
  fmt.Printf(&amp;quot;Successfully annnotated JUnit result with build info\n&amp;quot;)
  if err != nil {
    return err
  }
  req, err := http.NewRequest(&amp;quot;POST&amp;quot;, url, bytes.NewBuffer(json))

  req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)

  if err != nil {
    return err
  }

  client := &amp;amp;http.Client{}
  resp, err := client.Do(req)
  if err != nil {
    return err
  }
  defer resp.Body.Close()
  if (resp.StatusCode &amp;gt;= 200 &amp;amp;&amp;amp; resp.StatusCode &amp;lt; 300 ) {
    fmt.Printf(&amp;quot;Sent %s to %s\n&amp;quot;, path, url)
  } else {
    body, _ := ioutil.ReadAll(resp.Body)
    return errors.New(fmt.Sprintf(&amp;quot;HTTP status: %s; HTTP Body: %s\n&amp;quot;, resp.Status, body))
  }
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need to add a const to the go file which specifies the URL of the ElasticSearch instance. Add this to the top of &lt;code&gt;main.go&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const url = &amp;quot;http://jenkins-x-reports-elasticsearch-client:9200/tests/junit/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once you&amp;rsquo;ve resolved all the imports, you&amp;rsquo;ll notice that we still have some errors. That&amp;rsquo;s because we are missing a dependency on the &lt;code&gt;mxj&lt;/code&gt; library which we are using to work with XML and JSON. Make sure you have these imports:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  &amp;quot;github.com/clbanning/mxj&amp;quot;
  &amp;quot;github.com/clbanning/mxj/x2j&amp;quot;
  json2 &amp;quot;encoding/json&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then add this by running &lt;code&gt;dep init&lt;/code&gt; which will detect our dependency and set it up properly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We&amp;rsquo;ll also need to call it for each JUnit XML file we receive. And only for JUnit files. We can use the HTTP headers for this:
Just above where we write the success message to the HTTP stream, add this code to call &lt;code&gt;sendToElasticSearch()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    if r.Header.Get(&amp;quot;X-Content-Type&amp;quot;) == &amp;quot;text/vnd.junit-xml&amp;quot; {
      err = sendToElasticSearch(r.Body, r.URL.Path)
      if err != nil {
        renderError(w, &amp;quot;CANT_SEND_TO_ELASTICSEATCH&amp;quot;, http.StatusInternalServerError)
        log.Println(err)
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push your changes up to Git to have the updated server built on Jenkins X.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We now need to modify our script to send JUnit XML files with the mime type set to &lt;code&gt;text/vnd.junit-xml&lt;/code&gt;. In the &lt;code&gt;junit.sh&lt;/code&gt; file in the sample project modify the curl command in &lt;code&gt;upload_file()&lt;/code&gt; to add the header. The whole line should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    curl -H &amp;quot;X-Content-Type: text/vnd.junit-xml&amp;quot; -s -F upload=@$1 http://jenkins-x-reports-upload.jx-production/$path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are wondering why we use &lt;code&gt;X-Content-Type&lt;/code&gt; it is to avoid breaking the multipart form upload for the file!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And of course we need to remove &lt;code&gt;junit-runner&lt;/code&gt;. Delete the &lt;code&gt;dashboard()&lt;/code&gt; function and remove the call to it from &lt;code&gt;upload()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now, let&amp;rsquo;s clean things up a bit more by moving the code creating the configmap from the &lt;code&gt;junit.sh&lt;/code&gt; script into the &lt;code&gt;jenkins-x-reports&lt;/code&gt; code. First, we need to add a dependency on kubernetes-client to our code. Edit &lt;code&gt;Gopkg.toml&lt;/code&gt; and add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[constraint]]
  name = &amp;quot;k8s.io/api&amp;quot;
  version = &amp;quot;kubernetes-1.11.0&amp;quot;

[[constraint]]
  name = &amp;quot;k8s.io/apimachinery&amp;quot;
  version = &amp;quot;kubernetes-1.11.0&amp;quot;
[[constraint]]
  name = &amp;quot;k8s.io/client-go&amp;quot;
  version = &amp;quot;kubernetes-1.11.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now we can add this function to create the Kubernetes client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func createKubernetesClient() (*kubernetes.Clientset, error) {
  // creates the in-cluster config
  config, err := rest.InClusterConfig()
  if err != nil {
    return nil, err
  }
  // creates the clientset
  client, err := kubernetes.NewForConfig(config)
  if err != nil {
    return nil, err
  }
  return client, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And call it by adding these lines to the top of &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  client, err := createKubernetesClient()
  if err != nil {
    panic(err)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We now need to pass it to the &lt;code&gt;uploadServer()&lt;/code&gt; function and change the signature of &lt;code&gt;uploadServer()&lt;/code&gt; to &lt;code&gt;func uploadServer(client *kubernetes.Clientset)&lt;/code&gt;, and then do the same to &lt;code&gt;uploadFileHandler()&lt;/code&gt;, changing the signature to &lt;code&gt;func uploadServer(client *kubernetes.Clientset)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now, we can write a function that gets or creates the configmap:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getOrCreateConfigMap(org string, app string, client kubernetes.Interface) (*corev1.ConfigMap, error) {
  cmName := fmt.Sprintf(&amp;quot;%s-%s-test-reports&amp;quot;, org, app)
  cm, err := client.CoreV1().ConfigMaps(cmNamespace).Get(cmName, metav1.GetOptions{})
  if err != nil {
    return nil, err
  }
  if cm == nil {
    return client.CoreV1().ConfigMaps(cmNamespace).Create(&amp;amp;corev1.ConfigMap{
      ObjectMeta: metav1.ObjectMeta{
        Name: cmName,
      },
    })
    if err != nil {
      return nil, err
    }
  }
  return cm, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In order to pass the org name and the app name to the config map creator, we can pass them using HTTP Headers. We can call the config map creation from the &lt;code&gt;uploadFileHandler()&lt;/code&gt;, just before we write success by adding these lines to the top of the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // Get and validate headers
    org := r.Header.Get(&amp;quot;X-Org&amp;quot;)
    if org == &amp;quot;&amp;quot; {
      renderError(w, &amp;quot;MUST_PROVIDE_X-ORG_HEADER&amp;quot;, http.StatusInternalServerError)
      log.Println(&amp;quot;No X-ORG HEADER provided&amp;quot;)
    }
    app := r.Header.Get(&amp;quot;X-App&amp;quot;)
    if app == &amp;quot;&amp;quot; {
      renderError(w, &amp;quot;MUST_PROVIDE_X-APP_HEADER&amp;quot;, http.StatusInternalServerError)
      log.Println(&amp;quot;No X-APP HEADER provided&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this to the bottom, just above the success message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;getOrCreateConfigMap(org, app, client)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And before we forget, update the &lt;code&gt;junit.sh&lt;/code&gt; script to send these values. The curl command should now look like &lt;code&gt;curl -H &amp;quot;X-Content-Type: text/vnd.junit-xml&amp;quot; -H &amp;quot;X-ORG: ${ORG}&amp;quot; -H &amp;quot;X-APP: ${APP_NAME} -s -F upload=@$1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now, let&amp;rsquo;s implement the function &lt;code&gt;updateConfigMap()&lt;/code&gt; to perform the actual patch. Use this function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func updateConfigMap(cm *corev1.ConfigMap, version string, filename string, url string, client kubernetes.Interface) (*corev1.ConfigMap, error){
  fmt.Printf(&amp;quot;Updating %s with data for %s and Data %s\n&amp;quot;, cm.Name, version, cm.Data )
  if cm.Data[version] == &amp;quot;&amp;quot; {
    cm.Data[version] = fmt.Sprintf(&amp;quot;|-\n&amp;quot;)
  }
  cm.Data[version] = fmt.Sprintf(&amp;quot;%s\n    %s: %s\n&amp;quot;, cm.Data[version], filename, url)
  return client.CoreV1().ConfigMaps(cmNamespace).Update(cm)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now we need to figure out the host URL for the report downloads. Use this function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getReportHost(client kubernetes.Interface) (string, error) {
  svc, err := client.CoreV1().Services(&amp;quot;jx-production&amp;quot;).Get(&amp;quot;jenkins-x-reports&amp;quot;, metav1.GetOptions{})
  if err != nil {
    return &amp;quot;&amp;quot;, err
  }
  return svc.Annotations[&amp;quot;fabric8.io/exposeUrl&amp;quot;], nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We now need to wire it in. Add a version header to the top of the &lt;code&gt;uploadFileHandler()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;version := r.Header.Get(&amp;quot;X-Version&amp;quot;)
if version == &amp;quot;&amp;quot; {
  renderError(w, &amp;quot;MUST_PROVIDE_X-VERSION_HEADER&amp;quot;, http.StatusInternalServerError)
  log.Println(&amp;quot;No X-VERSION HEADER provided&amp;quot;)
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add just above the success message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cm, err := getOrCreateConfigMap(org, app, client)
    if err != nil {
        renderError(w, &amp;quot;ERROR_CREATING_CONFIG_MAP&amp;quot;, http.StatusInternalServerError)
        log.Println(err)
    }
    reportHost, err := getReportHost(client)
    if err != nil {
        renderError(w, &amp;quot;ERROR_CREATING_CONFIG_MAP&amp;quot;, http.StatusInternalServerError)
        log.Println(err)
    }

    url := fmt.Sprintf(&amp;quot;%s/%s/%s/%s/%s&amp;quot;, reportHost, org, app, version, filename)
    cm, err = updateConfigMap(cm, version, filename, url, client )
    if err != nil {
        renderError(w, &amp;quot;ERROR_UPDATING_CONFIG_MAP&amp;quot;, http.StatusInternalServerError)
        log.Println(err)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can also improve the way we are storing the files now, using the headers to create the path rather than just copying the path that was used for upload by changing the variable &lt;code&gt;dir&lt;/code&gt; to look more like &lt;code&gt;dir := filepath.Join(uploadPath, org, app, version)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, let&amp;rsquo;s tidy up &lt;code&gt;junit.sh&lt;/code&gt; by removing the remnants of the patching code and adding the version header. Your final curl command should look like: &lt;code&gt;curl -H &amp;quot;X-Content-Type: text/vnd.junit-xml&amp;quot; -H &amp;quot;X-Org: ${ORG}&amp;quot; -H &amp;quot;X-App: ${APP_NAME}&amp;quot; -H &amp;quot;X-Version: ${VERSION}&amp;quot; -s -F upload=@$1 http://jenkins-x-reports-upload.jx-production/$filename&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;progress-review&#34;&gt;Progress Review&lt;/h2&gt;

&lt;p&gt;We still have some steps to complete.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add token based authentication for the upload endpoint to prevent random pieces of code updating it (it&amp;rsquo;s only accessible in the cluster anyway)&lt;/li&gt;
&lt;li&gt;Allow contribution to build health (requires additional JX support &lt;code&gt;jx step post&lt;/code&gt; and &lt;code&gt;jx step pre&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this point the JX team have also learned that we want to build some additional extension points into Jenkins X:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;jx step post&lt;/code&gt; support for a &amp;lsquo;post build` steps. This will allow us to implement build health, as it will allow us to:

&lt;ul&gt;
&lt;li&gt;Inject additional steps into the build that allow us to run e.g. &lt;code&gt;mvn surefire-report:report&lt;/code&gt; without modifying the build&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jx step collect&lt;/code&gt; for collecting build artifact that will run even if the build fails

&lt;ul&gt;
&lt;li&gt;Add URLs to the &lt;code&gt;PipelineActivity&lt;/code&gt; CRD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TODO complete the guide&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
