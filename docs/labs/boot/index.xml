<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X â€“ Boot</title>
    <link>/docs/labs/boot/</link>
    <description>Recent content in Boot on Jenkins X</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/labs/boot/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Getting Started</title>
      <link>/docs/labs/boot/getting-started/</link>
      <pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/getting-started/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Multi-Cluster</title>
      <link>/docs/labs/boot/multi-cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/multi-cluster/</guid>
      <description>
        
        
        &lt;p&gt;We recommend using separate clusters for your &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments. This lets you completely isolate your environments which improves security.&lt;/p&gt;
&lt;h2 id=&#34;setting-up-multi-cluster&#34;&gt;Setting up multi cluster&lt;/h2&gt;
&lt;p&gt;To enable multi cluster you need to specify &lt;code&gt;remoteCluster: true&lt;/code&gt; on your &lt;code&gt;Staging&lt;/code&gt; and/or &lt;code&gt;Production&lt;/code&gt; environments in your &lt;code&gt;jx-requirements.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The easiest way to do that is passing in &lt;code&gt;--env-remote&lt;/code&gt;  when you &lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;created your environment git repositories&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl boot create --env-remote
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or if you&amp;rsquo;ve already &lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;created your environment git repositories&lt;/a&gt; you can modify your &lt;code&gt;jx-requirements.yml&lt;/code&gt; to something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bootConfigURL&lt;/span&gt;: https://github.com/jenkins-x/jenkins-x-boot-helmfile-config
&lt;span style=&#34;color:#66d9ef&#34;&gt;cluster&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitKind&lt;/span&gt;: github
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitName&lt;/span&gt;: github
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitServer&lt;/span&gt;: https://github.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: jx
&lt;span style=&#34;color:#66d9ef&#34;&gt;environments&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: dev
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: staging
  &lt;span style=&#34;color:#66d9ef&#34;&gt;remoteCluster&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: production
  &lt;span style=&#34;color:#66d9ef&#34;&gt;remoteCluster&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;gitops&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;helmfile&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;kaniko&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: nexus
&lt;span style=&#34;color:#66d9ef&#34;&gt;secretStorage&lt;/span&gt;: local
&lt;span style=&#34;color:#66d9ef&#34;&gt;versionStream&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ref&lt;/span&gt;: v1&lt;span style=&#34;color:#ae81ff&#34;&gt;.0.330&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;url&lt;/span&gt;: https://github.com/jenkins-x/jenkins-x-versions.git
&lt;span style=&#34;color:#66d9ef&#34;&gt;webhook&lt;/span&gt;: lighthouse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;setup-the-development-cluster-as-normal&#34;&gt;Setup the development cluster as normal&lt;/h3&gt;
&lt;p&gt;Follow the &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;getting started guide for helm 3 boot&lt;/a&gt; to setup the secrets and boot up the development cluster.&lt;/p&gt;
&lt;h3 id=&#34;configure-the-stagingproduction-git-repository&#34;&gt;Configure the Staging/Production git repository&lt;/h3&gt;
&lt;p&gt;First make sure you do:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export NAMESPACE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;jx-staging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you will need to follow the instructions to &lt;a href=&#34;/docs/labs/boot/getting-started/cloud/&#34;&gt;setup the cloud resources for the Staging/Production cluster&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When you are connected to the Staging/Production cluster you will need to run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl verify requirements --git-url=https://github.com/myorg/environment-mycluster-staging.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will ensure that your &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in your &lt;code&gt;staging&lt;/code&gt; / &lt;code&gt;production&lt;/code&gt; git repository is setup to point at the correct cloud resources.&lt;/p&gt;
&lt;p&gt;Then follow the &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;secrets setup&lt;/a&gt; and  &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;run the boot job&lt;/a&gt; for the &lt;code&gt;staging&lt;/code&gt; / &lt;code&gt;production&lt;/code&gt; environment&lt;/p&gt;
&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;Once you run &lt;code&gt;jx boot&lt;/code&gt; on your development cluster you will get a helm 3 based installation of Jenkins X as usual but with a few differences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;Environment&lt;/code&gt; resources for &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; marked as &lt;code&gt;remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;SourceRepository&lt;/code&gt; resources for &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; will reference the &lt;code&gt;pr-only&lt;/code&gt; &lt;code&gt;Scheduler&lt;/code&gt; which means only the Pull Request pipelines will run on the development cluster; the release pipelines will run in the remote cluster.&lt;/li&gt;
&lt;li&gt;the git repository for the &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments will use the helmfile + helm 3 layout structure (using an &lt;code&gt;apps&lt;/code&gt; folder instead of &lt;code&gt;env&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;setting-up-the-remote-stagingproduction-cluster&#34;&gt;Setting up the remote Staging/Production cluster&lt;/h3&gt;
&lt;p&gt;First make a note of the git repository locations of your &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments via the &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_environments/&#34;&gt;jx get env&lt;/a&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx get env
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now follow the &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/create-cluster/&#34;&gt;usual steps to create your kubernetes cluster&lt;/a&gt; and connect to the cluster so that &lt;code&gt;kubectl get node&lt;/code&gt; runs against the &lt;code&gt;Staging&lt;/code&gt; or &lt;code&gt;Production&lt;/code&gt; cluster you want to setup.&lt;/p&gt;
&lt;p&gt;Then git clone the git repository for the &lt;code&gt;Staging&lt;/code&gt; / &lt;code&gt;Production&lt;/code&gt; environment and &lt;code&gt;cd&lt;/code&gt; into the directory.&lt;/p&gt;
&lt;p&gt;Now run &lt;code&gt;jx boot&lt;/code&gt; in the usual way&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx boot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And your remote &lt;code&gt;Staging&lt;/code&gt; or &lt;code&gt;Production&lt;/code&gt; cluster should boot up.&lt;/p&gt;
&lt;p&gt;If you want to add any more apps to your cluster, use the &lt;a href=&#34;/docs/labs/boot/apps/#adding-apps-or-charts&#34;&gt;jx add app&lt;/a&gt; command.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Progressive Delivery</title>
      <link>/docs/labs/boot/progressive-delivery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/progressive-delivery/</guid>
      <description>
        
        
        &lt;p&gt;Progressive delivery allows you to gradually rollout new versions of your application to an environment using &lt;em&gt;canaries&lt;/em&gt; and gradually giving traffic to the new version until you are happy to fully rollover to the new version.&lt;/p&gt;
&lt;p&gt;Our recommendation for using progressive delivery with Jenkins X is to use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; as the progressive delivery controller&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt; as the service mesh to provider advanced load balancing capabilities across internal or external networking&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;configuring-progressive-delivery&#34;&gt;Configuring Progressive Delivery&lt;/h2&gt;
&lt;p&gt;Please follow the usual &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;getting started guide for boot and helm 3&lt;/a&gt; but before &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running boot&lt;/a&gt; please make sure you make the following configuration:&lt;/p&gt;
&lt;h3 id=&#34;add-the-istio-and-flagger-apps&#34;&gt;Add the istio and flagger apps&lt;/h3&gt;
&lt;p&gt;Please make sure your &lt;code&gt;jx-apps.yml&lt;/code&gt; has the necessary apps for using &lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; and &lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt;. Your &lt;code&gt;jx-apps.yml&lt;/code&gt; in your development environment git repository should look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jx-labs/istio
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: flagger/flagger
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: flagger/grafana
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jx-labs/flagger-metrics
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/kuberhealthy
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So that you remove &lt;code&gt;stable/nginx-ingress&lt;/code&gt; from your &lt;code&gt;jx-apps.yml&lt;/code&gt; file and ensure the above apps are added at the top of the file.&lt;/p&gt;
&lt;p&gt;Also for now I&amp;rsquo;m afraid you will have to remove the &lt;code&gt;jenkins-x/jxui&lt;/code&gt; chart as its currently not working yet with istio ingress - but we can hopefully get that working soon.&lt;/p&gt;
&lt;h3 id=&#34;enable-istio-based-ingress&#34;&gt;Enable istio based ingress&lt;/h3&gt;
&lt;p&gt;To avoid having 2 &lt;code&gt;LoadBalancer&lt;/code&gt; services for both &lt;code&gt;istio&lt;/code&gt; and &lt;code&gt;nginx&lt;/code&gt; (which costs more money) its easier to switch to pure istio for both internal and external load balancing. This also results in a smaller footprint.&lt;/p&gt;
&lt;p&gt;To do that ensure that &lt;code&gt;kind: istio&lt;/code&gt; is added to the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in the top level &lt;code&gt;ingress:&lt;/code&gt; section like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: istio
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;now-boot&#34;&gt;Now boot&lt;/h3&gt;
&lt;p&gt;Now your development git repository should be setup and be ready. Now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make sure you have setup &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;any secrets you need to boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;now &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;run boot&lt;/a&gt; to setup your installation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When it is all complete you should see istio, flagger, grafana pods running in the &lt;code&gt;istio-system&lt;/code&gt; namespace something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get pod -n istio-system
NAME                                    READY   STATUS    RESTARTS   AGE
flagger-66dc49cd-g6ptp                  1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
grafana-7d7d7476f6-ff6bm                1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
istio-ingressgateway-598796f4d9-sq8b7   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
istiod-7d9c7bdd6-vjp9j                  1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
kuberhealthy-f54f7f7df-b5gbf            1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;          32h
kuberhealthy-f54f7f7df-j6qwt            1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
prometheus-b47d8c58c-n974m              2/2     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From 1.5 onwards istio is pretty small; just 2 pods. Note that those &lt;code&gt;kuberhealthy&lt;/code&gt; pods are optional and just help with reporting.&lt;/p&gt;
&lt;h3 id=&#34;enable-istio-in-stagingproduction&#34;&gt;Enable istio in staging/production&lt;/h3&gt;
&lt;p&gt;If you wish to use a Canary with &lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; and &lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt; in your staging or production namespace you need to make sure you have labelled the namespace correctly to enable istio injection.&lt;/p&gt;
&lt;p&gt;To enable istio in staging:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl label namespace jx-staging istio-injection&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To enable istio in production:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl label namespace jx-production istio-injection&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;defaulting-to-use-canary&#34;&gt;Defaulting to use Canary&lt;/h3&gt;
&lt;p&gt;Run the following command to default to using canary deployments and horizontal pod autoscaling whenever you &lt;a href=&#34;/docs/getting-started/first-project/create-quickstart/&#34;&gt;create a new quickstart&lt;/a&gt; or &lt;a href=&#34;/docs/using-jx/creating/import/&#34;&gt;import a project&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jxl edit deploy --team --canary --hpa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will enable all new quickstarts and imported projects to use canary rollouts and use horizontal pod autoscaling in all environments.&lt;/p&gt;
&lt;p&gt;You can switch the defaults back again at any time or configure any app to change its defaults by running &lt;code&gt;jxl edit deploy&lt;/code&gt; inside a git clone of an application.&lt;/p&gt;
&lt;h3 id=&#34;enablingdisabling-canaryhpa-in-an-environment&#34;&gt;Enabling/Disabling Canary/HPA in an Environment&lt;/h3&gt;
&lt;p&gt;If you want to enable/disable canary or horizontal pod autoscaling for a specific app in an environment then you can &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;follow the app customisation approach&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Assuming your app is called &lt;code&gt;myapp&lt;/code&gt; then in the git repository for the environment (e.g. &lt;code&gt;Staging&lt;/code&gt;) you can add/edit a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; to look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;canary&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;hpa&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;you can enable/disable those 2 flags for canary releases and horizontal pod autoscaler at any point in any environment.&lt;/p&gt;
&lt;h2 id=&#34;using-progressive-delivery&#34;&gt;Using Progressive Delivery&lt;/h2&gt;
&lt;p&gt;Once you have followed the above steps create a &lt;a href=&#34;/docs/getting-started/first-project/create-quickstart/&#34;&gt;quickstart application&lt;/a&gt; in the usual way.&lt;/p&gt;
&lt;p&gt;As you merge changes to the master branch of your application Jenkins X will create a new release and &lt;a href=&#34;/docs/using-jx/faq/#how-does-promotion-actually-work&#34;&gt;promote it to the staging environment&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However if Canary deployment is enabled your new version will gradually be rolled out progressively:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the defaults are that 20% of the traffic will go to the new version&lt;/li&gt;
&lt;li&gt;flagger will keep monitoring the metrics used in the Canary resource to determine if the canary is good&lt;/li&gt;
&lt;li&gt;after the configured time period is over the traffic will be increased to 40% then 60%&lt;/li&gt;
&lt;li&gt;eventually if things look good the new version will fully rollout to 100% traffic&lt;/li&gt;
&lt;li&gt;if anything goes bad during the rollout time period the old version is restored&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is an excellent &lt;a href=&#34;https://youtu.be/7eePqtxW7NM&#34;&gt;video showing this in action&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Benefits</title>
      <link>/docs/labs/boot/benefits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/benefits/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;We can use vanilla helm 3 now to install, update or delete charts in any namespace without needing tiller or custom code to manage &lt;code&gt;helm template&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;We can avoid all the complexities of the &lt;code&gt;jx step helm apply&lt;/code&gt; logic using our own helm template generation + post processing logic. We can also move away from boot&amp;rsquo;s use of &lt;code&gt;{{ .Requirements.foo }}&lt;/code&gt; and &lt;code&gt;{{ .Parameters.bar }}&lt;/code&gt; expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It opens the door to a flexible &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multi-cluster support&lt;/a&gt; so that every cluster/environment can be managed in the same canonical GitOps approach (as each cluster can use &lt;code&gt;jx boot&lt;/code&gt; whether its a dev environment or remote staging/production environment)&lt;/li&gt;
&lt;li&gt;We can use the &lt;code&gt;helm list&lt;/code&gt; command line to view versions of each chart/app nicely in the CLI.
&lt;ul&gt;
&lt;li&gt;we can avoid composite charts to simplfiy configuration and upgrades&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Everything is now an app. So if you want to remove our &lt;code&gt;nginx-ingress&lt;/code&gt; chart and replace it with another ingress solution (knative / istio / gloo / ambassador / linkerd or whatever) just go ahead and use the &lt;a href=&#34;/docs/labs/boot/apps/&#34;&gt;apps commands&lt;/a&gt; to add/remove apps and have boot manage everything in a consistent way
&lt;ul&gt;
&lt;li&gt;e.g. here&amp;rsquo;s &lt;a href=&#34;https://github.com/jstrachan/environment-bucketrepo-dev/blob/master/jx-apps.yml#L2-L5&#34;&gt;an example&lt;/a&gt; of removing &lt;code&gt;nginx&lt;/code&gt;, &lt;code&gt;chartmusem&lt;/code&gt; and &lt;code&gt;nexus&lt;/code&gt; and adding in &lt;code&gt;istio&lt;/code&gt;, &lt;code&gt;flagger&lt;/code&gt; and some other tools like &lt;code&gt;bucketrepo&lt;/code&gt; and &lt;code&gt;kuberhealthy&lt;/code&gt; via a single simple yaml change. Incidentally to replace the use of &lt;code&gt;Ingress&lt;/code&gt; resources with istio&amp;rsquo;s &lt;code&gt;Gateway&lt;/code&gt; and &lt;code&gt;VirtualService&lt;/code&gt; you also need to add the &lt;code&gt;kind: istio&lt;/code&gt; flag in the &lt;a href=&#34;https://github.com/jstrachan/environment-bucketrepo-dev/blob/master/jx-requirements.yml#L57&#34;&gt;jx-requirements.yml&lt;/a&gt; file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You can install an app in a specific namespace if you wish
&lt;ul&gt;
&lt;li&gt;This also opens the door to using boot to setup multi-team installations where multiple teams use different namespaces but share services in the same cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The new &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;jxl boot run&lt;/a&gt; command runs the boot pipeline as a &lt;code&gt;Job&lt;/code&gt; inside the Kubernetes cluster. This ensures consistency in tooling used and also improves security by avoiding having the secrets on a developers laptop.&lt;/li&gt;
&lt;li&gt;The boot git repository is much smaller and simpler; less to keep in sync/rebase/merge with the upstream git repository. Its mostly just 2 YAML files now &lt;code&gt;jx-requirements.yml&lt;/code&gt; and &lt;code&gt;jx-apps.yml&lt;/code&gt; which are both pretty much specific to your cluster installation. The &lt;code&gt;jenkins-x.yml&lt;/code&gt; pipeline is configured inside the build pack so usually is 1 simple line long. So there&amp;rsquo;s no need for all the git merge/rebase/cherry pick logic in jx 2.x
&lt;ul&gt;
&lt;li&gt;we rely more instead on the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; which can be shared across installations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the boot process is split up into &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;separate phases&lt;/a&gt; which makes things easier to iterate and configure:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/cloud/&#34;&gt;setting up the cloud resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;creating the git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;setting up secrets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we no longer use &lt;code&gt;exposecontroller&lt;/code&gt; and use regular helm configuration to create &lt;code&gt;Ingress&lt;/code&gt; resources and &lt;a href=&#34;/docs/labs/boot/faq/#how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;override domain names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;secret handling is currently much simpler:
&lt;ul&gt;
&lt;li&gt;You can specify all the secrets &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;setup up the secrets&lt;/a&gt; before &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt; by importing a &lt;code&gt;secrets.yaml&lt;/code&gt; or entering them directly&lt;/li&gt;
&lt;li&gt;we support Google Secret Manager or a Kubernetes Secret current; but this simple &lt;a href=&#34;https://github.com/jenkins-x-labs/helmboot/blob/master/pkg/secretmgr/interface.go#L5&#34;&gt;SecretManager&lt;/a&gt; interface should be super easy to implement for other cloud secrets providers or managed vault installations.&lt;/li&gt;
&lt;li&gt;the simpler secrets handling means we can run the &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt; inside the kubernetes cluster for better security&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Comparison</title>
      <link>/docs/labs/boot/comparison/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/comparison/</guid>
      <description>
        
        
        &lt;p&gt;This document outlines the similarities and differences of the helmfile / helm 3 approach for those who are aware of &lt;code&gt;jx boot&lt;/code&gt; with helm 2.&lt;/p&gt;
&lt;h2 id=&#34;similarities-with-jx-boot-and-helm-2&#34;&gt;Similarities with &lt;code&gt;jx boot&lt;/code&gt; and helm 2&lt;/h2&gt;
&lt;p&gt;Just like classic boot with the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/&#34;&gt;jenkins-x-boot-config&lt;/a&gt; git repository, this new &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; solution supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can run &lt;code&gt;jx boot&lt;/code&gt; to spin up a new git repository for your development environment&lt;/li&gt;
&lt;li&gt;you can run &lt;code&gt;jx boot&lt;/code&gt; at any time to reapply changes from your laptop or can trigger a CI/CD pipeline using tekton to do the same thing&lt;/li&gt;
&lt;li&gt;the git repository contains a &lt;code&gt;jenkins-x.yml&lt;/code&gt; to implement the boot pipeline&lt;/li&gt;
&lt;li&gt;a YAML file is used to store all the charts that are applied using &lt;code&gt;jx boot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;differences-with-jx-boot-and-helm-3&#34;&gt;Differences with &lt;code&gt;jx boot&lt;/code&gt; and helm 3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;we use helm 3 along with &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; to actually apply the helm charts into a kubernetes cluster&lt;/li&gt;
&lt;li&gt;any helm chart can be deployed in any namespace (previously we used 1 namespace for all charts in the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;we no longer use a composite chart for &lt;code&gt;env/Chart.yaml&lt;/code&gt; and instead deploy each chart independently
&lt;ul&gt;
&lt;li&gt;this means that each chart has its own unique version number; so that &lt;code&gt;helm list&lt;/code&gt; gives nice meaningful results&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we have done away with the complexity of &lt;code&gt;jenkins-x-platform&lt;/code&gt; (a composite chart containing logs of &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/requirements.yaml&#34;&gt;dependencies&lt;/a&gt; like &lt;code&gt;jenkins&lt;/code&gt; + &lt;code&gt;chartmuseum&lt;/code&gt; + &lt;code&gt;nexus&lt;/code&gt; etc) so that each chart can be added/removed independently or swapped out with a different version/distribution&lt;/li&gt;
&lt;li&gt;instead of using &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt; we now use a simple and more powerful &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file which is similar but supports:
&lt;ul&gt;
&lt;li&gt;we can specify a &lt;code&gt;namespace&lt;/code&gt; on any chart&lt;/li&gt;
&lt;li&gt;we can add extra &lt;code&gt;valuesFiles&lt;/code&gt; to use with the chart to override the helm &lt;code&gt;values.yaml&lt;/code&gt; files&lt;/li&gt;
&lt;li&gt;different &lt;code&gt;phase&lt;/code&gt; values so that we can default some charts like &lt;code&gt;nginx-ingress&lt;/code&gt; to the &lt;code&gt;system&lt;/code&gt; phase before we setup ingress, DNS, TLS and certs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;instead of copying lots of &lt;code&gt;env/$appName/values*.yaml&lt;/code&gt; files into the boot config like we do in &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/&#34;&gt;these folders&lt;/a&gt; such as &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/lighthouse/values.tmpl.yaml&#34;&gt;the lighthouse/values.tmpl.yaml&lt;/a&gt; we can instead default all of these from the version stream at &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/lighthouse&#34;&gt;apps/jenkins-x/lighthouse&lt;/a&gt; - which means the boot config git repository is much simpler, we can share more configuration with the version stream and it avoids lots of git merge/rebase issues.&lt;/li&gt;
&lt;li&gt;since we are using helm 3 directly you can add/remove apps and re-run &lt;code&gt;jx boot&lt;/code&gt; and things are removed correctly.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Apps framework</title>
      <link>/docs/labs/boot/apps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/apps/</guid>
      <description>
        
        
        &lt;p&gt;The new &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; and helm 3 approach extends the app extension model in Jenkins X.&lt;/p&gt;
&lt;p&gt;In essence that means if you are using helmfile you can use the usual Apps commands which create Pull Requests on the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file in your environments git repository rather than the traditional &lt;code&gt;env/requirements.yaml&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;This also means you can have apps in different namespaces. e.g. its common to put some charts in different namespaces like &lt;code&gt;nginx-ingress&lt;/code&gt;, &lt;code&gt;gloo&lt;/code&gt;, &lt;code&gt;cert-mangager&lt;/code&gt; etc.&lt;/p&gt;
&lt;h3 id=&#34;viewing-apps&#34;&gt;Viewing apps&lt;/h3&gt;
&lt;p&gt;You can view your apps across all namespaces via &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_apps/&#34;&gt;jx get app&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl get app
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will effectively display data from the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt;. This data will be pretty close to using a regular &lt;code&gt;helm list&lt;/code&gt; using helm 3.x or later; only it will show apps across all namespaces by default..&lt;/p&gt;
&lt;h3 id=&#34;adding-apps-or-charts&#34;&gt;Adding apps or charts&lt;/h3&gt;
&lt;p&gt;you can use &lt;a href=&#34;https://jenkins-x.io/commands/jx_add_app/&#34;&gt;jxl add app&lt;/a&gt; to add any helm chart to your installation using the usual helm style notation of &lt;code&gt;repositoryPrefix/chartName&lt;/code&gt; such as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl add app jetstack/cert-manager
jxl add app flagger/flagger

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;these commands will implicitly use the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; configuration (via &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/charts/repositories.yml&#34;&gt;charts/repositories.yml&lt;/a&gt;) to determine the mapping of prefixes to repository URLs.&lt;/p&gt;
&lt;p&gt;Then these commands will create Pull Requests on the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file in your environments git repository.&lt;/p&gt;
&lt;p&gt;Note that usually the Pull Request will only add a simple line of the format to the &lt;code&gt;apps:&lt;/code&gt; entry:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apps:
- name: jetstack/cert-manager 
- name: flagger/flagger
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This keeps the configuration in the environment git repository nice and concise. The &lt;code&gt;version&lt;/code&gt; of the chart is then resolved during deployment via the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;adding-new-kubernetes-resources&#34;&gt;Adding new kubernetes resources&lt;/h3&gt;
&lt;p&gt;Sometimes you just want to add one or more kubernetes resources such as an &lt;code&gt;Ingress&lt;/code&gt; or &lt;code&gt;ConfigMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Helmfile supports using helm charts in source code format; so its easy to add any kubernetes resources directly via YAML files.&lt;/p&gt;
&lt;p&gt;e.g. if you look in the &lt;code&gt;repositories/templates&lt;/code&gt; folder you will see at least one YAML resource. So you could just add more YAML files to that folder.&lt;/p&gt;
&lt;p&gt;Though you may want to separate out your resources into their own chart; so you could add a new folder structure like the &lt;code&gt;resources&lt;/code&gt; folder. e.g. add these files:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mythings/
  Chart.yaml
  templates/
     some-resource.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then to reference &lt;code&gt;mythings&lt;/code&gt; add the following to your &lt;code&gt;jx-apps.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: mythings
  repository: &amp;quot;..&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then longer term if you want to turn your chart &lt;code&gt;mythings&lt;/code&gt; into a released chart you could create a new git repository and move the folder there, then just remove the &lt;code&gt;repository:&lt;/code&gt; entry in the &lt;code&gt;jx-apps.yml&lt;/code&gt; to reference the released chart instead.&lt;/p&gt;
&lt;h3 id=&#34;customising-charts&#34;&gt;Customising charts&lt;/h3&gt;
&lt;p&gt;You can add custom &lt;code&gt;values.yaml&lt;/code&gt; files for a chart by adding the file to &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt;. This file will then be referenced in the generated &lt;code&gt;apps/helmfile.yaml&lt;/code&gt; file and passed into &lt;code&gt;helm&lt;/code&gt; when you next run &lt;code&gt;jxl boot run&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also use a file called &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; if you wish to use go templating of the values file. For example this lets you reference properties from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file via expressions like &lt;code&gt;{{ .Values.jxRequirements.ingress.domain }}&lt;/code&gt;. You can also reference the shared secrets in your &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; file via &lt;code&gt;{{ .Values.secrets.pipelineUser.username }}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To see an example of this in action check out the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/tekton/values.yaml.gotmpl&#34;&gt;apps/jenkins-x/tekton/values.yaml.gotmpl&lt;/a&gt; file in the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that many apps are already configured to make use of the &lt;code&gt;jx-requirements.yml&lt;/code&gt; settings via the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; - but you are free to add your own custom configuration.&lt;/p&gt;
&lt;h3 id=&#34;removing-apps&#34;&gt;Removing apps&lt;/h3&gt;
&lt;p&gt;To remove an app use &lt;a href=&#34;https://jenkins-x.io/commands/jx_delete_app/&#34;&gt;jx delete app&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl delete app jetstack/cert-manager
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Background</title>
      <link>/docs/labs/boot/background/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/background/</guid>
      <description>
        
        
        &lt;p&gt;see the &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6442&#34;&gt;issue&lt;/a&gt; and &lt;a href=&#34;https://github.com/jenkins-x/enhancements/tree/master/proposals/2&#34;&gt;enhancement proopsal&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;We want a simple canonical way to install any helm chart in any namespace without having to manually hack the &lt;code&gt;jx boot&lt;/code&gt; pipeline file: &lt;code&gt;jenkins-x.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This will make it easy for people or software to easily add/remove apps to any git repository for any Environment (dev / staging / production).&lt;/p&gt;
&lt;p&gt;The boot config repo has become quite complex and hard to manage upgrades to and share common config between different flavours of base boot config repos.  Itâ€™s also hard to experiment by adding new helm charts / features / applications that require changes to the boot install pipeline.&lt;/p&gt;
&lt;p&gt;We want a simpler more modular system that lets us, say, swap out nginx-controller and use gloo/knative/istio for ingress without a deep knowledge of the jenkins-x.yml pipeline for boot.&lt;/p&gt;
&lt;p&gt;What weâ€™d really like is for folks to type commands likeâ€¦&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx delete app nginx-controller
jx add app istio
jx delete app knative
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And for it to just work and generically add those to the right namespace.&lt;/p&gt;
&lt;h2 id=&#34;current-limitations&#34;&gt;Current Limitations&lt;/h2&gt;
&lt;p&gt;The current apps model lets you add/remove charts fine - but there are a number of limitations:&lt;/p&gt;
&lt;h3 id=&#34;only-works-in-1-namespace&#34;&gt;Only works in 1 namespace&lt;/h3&gt;
&lt;p&gt;Currently apps can only work inside the dev namespace - we canâ€™t support things like knative, gloo, cert-manager, nginx, velero which tend to be installed in separate namespaces.&lt;/p&gt;
&lt;p&gt;###Â Does not handle boot phases&lt;/p&gt;
&lt;p&gt;This is not surprising as we created the App extension model before boot. But right now boot has a number of distinct phases with pipeline steps between them where we may want to add apps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pre/post ingress setup (in the case of nip.io / nginx-controller)&lt;/li&gt;
&lt;li&gt;pre/post vault setup&lt;/li&gt;
&lt;li&gt;pre/post vault population of parameters&lt;/li&gt;
&lt;li&gt;pre/post setup of certmanager/external dns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is currently no way for an apps to specify a namespace + specify which phase its to be installed in &amp;amp; have (say) the domain / certs / secrets injected easily.&lt;/p&gt;
&lt;p&gt;So rather than adding steps at the right point in a list of steps in the jenkins-x.yml it would be nice to have a more declarative YAML file to describe which apps are to be enabled.&lt;/p&gt;
&lt;p&gt;E.g. we need a new YAML file with list of charts to be installed along with metadata for which phase to install them. We also want to invoke a selection of those appss to be installed at the different phases of the boot pipeline.&lt;/p&gt;
&lt;h3 id=&#34;limitations-of-the-current-deploy-model&#34;&gt;Limitations of the current deploy model&lt;/h3&gt;
&lt;p&gt;We have some issues with the current way we deploy apps in Staging / Production:&lt;/p&gt;
&lt;h4 id=&#34;composite-charts-hide-the-individual-versions&#34;&gt;Composite charts hide the individual versions&lt;/h4&gt;
&lt;p&gt;Right now we deploy all charts in Staging/Production as a single chart. That means if you use &lt;code&gt;helm list&lt;/code&gt; we don&amp;rsquo;t show any actual versions of the dependent charts - its just 1 chart (with no version).&lt;/p&gt;
&lt;h4 id=&#34;removing-apps-on-dev-doesnt-work&#34;&gt;Removing Apps on Dev doesn&amp;rsquo;t work&lt;/h4&gt;
&lt;p&gt;If you remove a chart from &lt;code&gt;env/requirements.yaml&lt;/code&gt;  in the Dev repository the pipeline does not remove the chart. e.g. if you add &lt;code&gt;lighthouse&lt;/code&gt; and remove &lt;code&gt;prow&lt;/code&gt; you need to manually delete the prow resources yourself.&lt;/p&gt;
&lt;h3 id=&#34;limitation-of-boot&#34;&gt;Limitation of boot&lt;/h3&gt;
&lt;p&gt;We currently manually configure in the boot pipeline the install of multiple systems usually in separate namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;velero (if enabled)&lt;/li&gt;
&lt;li&gt;nginx&lt;/li&gt;
&lt;li&gt;externaldns&lt;/li&gt;
&lt;li&gt;cert-manager&lt;/li&gt;
&lt;li&gt;acme certs chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally those should be modular and optional. e.g it should be really trivial to disable nginx if folks are using, say, istio - without having to hack a pipeline yaml.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;d also like to make it easy to add a number of other systems in order in separate namespaces independently of the &lt;code&gt;Staging / Production&lt;/code&gt; environment namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knative &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6331&#34;&gt;https://github.com/jenkins-x/jx/issues/6331&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gloo&lt;/li&gt;
&lt;li&gt;istio&lt;/li&gt;
&lt;li&gt;linkerd &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6330&#34;&gt;https://github.com/jenkins-x/jx/issues/6330&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;flagger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so it&amp;rsquo;d be nice to have a simple app model where anyone can add any systems/charts to any namespace at any point in the flow before we setup the dev/staging/production environment in the traditional way.&lt;/p&gt;
&lt;h2 id=&#34;proposal&#34;&gt;Proposal&lt;/h2&gt;
&lt;p&gt;We propose we combine the extensibility of Jenkins X using Apps with &lt;code&gt;jx boot&lt;/code&gt; via a simple declarative YAML file declaring the charts to be installed.&lt;/p&gt;
&lt;p&gt;e.g. a file &lt;code&gt;apps.yaml&lt;/code&gt;  something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;defaultNamespace&lt;/span&gt;: jx

&lt;span style=&#34;color:#66d9ef&#34;&gt;releases&lt;/span&gt;: 
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: kube-system   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: external-dns
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.bitnami.com/bitnami
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.jetstack.io
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: cert-manager  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jxboot-resources
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: prow.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: lighthouse.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: bucketrepo.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jenkins-x-platform
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using a yaml file in a boot config repo we list the apps that should be installed.  This means we can instead have a bare minimum base boot config repo and list the apps we want installed and different points of the installation process.&lt;/p&gt;
&lt;p&gt;The above YAML looks quite like the &lt;code&gt;env/requirements.yaml&lt;/code&gt; file only:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it allows the &lt;code&gt;namespace&lt;/code&gt; to be specified if its different from the &lt;code&gt;defaultNamespace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;we add the &lt;code&gt;phase&lt;/code&gt; label so that we can filter the apps by phase so we can install different charts at different points in the boot pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###Â Strawman Solutions&lt;/p&gt;
&lt;p&gt;The above &lt;code&gt;apps.yaml&lt;/code&gt; proposal looks very much like helmfile.&lt;/p&gt;
&lt;p&gt;So lets look into helmfile and try using it with a stripped back boot config repo to see how things might fit together&lt;/p&gt;
&lt;p&gt;One possible solution might be to add a single step the boot pipeline to invoke helmfile: &lt;a href=&#34;https://github.com/roboll/helmfile#configuration&#34;&gt;https://github.com/roboll/helmfile#configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;e.g. given the &lt;code&gt;apps.yaml&lt;/code&gt; file in the file system then run helmfile as a step on the file.&lt;/p&gt;
&lt;p&gt;It looks like helmfile already supports tillerless + helm3 and lets us define namespaces and orders etc.&lt;/p&gt;
&lt;p&gt;We may need to build our own step to wrap helmfile so that we can do some of the things we do with &lt;code&gt;jx step helm apply&lt;/code&gt; right now (e.g. exposing the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file as a &lt;code&gt;values.yaml&lt;/code&gt; its values can be used inside any &lt;code&gt;values.yaml&lt;/code&gt; we use in the charts).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;should we support access to secrets in vault / local file system via URLs or Parameters injection?&lt;/li&gt;
&lt;li&gt;do we need to support exposing the properties from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; as values.yaml files that can be reused inside the helmfile templates?&lt;/li&gt;
&lt;li&gt;do we need to improve access to certs / domain after we&amp;rsquo;ve set those up in boot?&lt;/li&gt;
&lt;li&gt;allow the use of version streams to manage versions of things if no version is specified in the &lt;code&gt;helmfile.yaml&lt;/code&gt; - like we do with helm charts requirements.yaml file right now (in &lt;code&gt;jx step helm apply&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if we do need anything other than vanilla helmfile we could maybe do a similar thing to &lt;code&gt;jx step helm apply&lt;/code&gt; where we copy the directory where helmfile lives, then generate any secret yamls + &lt;code&gt;jx-requirements.yaml&lt;/code&gt; files and then run helmfile in a temporary directory (to avoid accidentally committing any secrets to git). Hopefully we don&amp;rsquo;t need to fork helmfile; but we could just wrap it slightly with a pre-processor?&lt;/p&gt;
&lt;p&gt;We want to allow the &lt;code&gt;jx boot&lt;/code&gt; pipeline to invoke a helmfile like thing at the different phases.&lt;/p&gt;
&lt;p&gt;e.g. currently in boot we do something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;install a bunch of charts in different namespaces with a defined order&lt;/li&gt;
&lt;li&gt;then we modify the requirements based on ingress: &lt;code&gt;jx step create install values&lt;/code&gt; (to handle things like detecting the domain/ingress)&lt;/li&gt;
&lt;li&gt;install more charts (e.g. external dns/cert manager/vault)&lt;/li&gt;
&lt;li&gt;populate parameters/secrets (&lt;code&gt;jx step create values --name parameters&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;do the traditional install and maybe other charts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so we already have 3 natural places to invoke a helmfile-like thing to install charts in different phases. So maybe thats 3 places where we invoke helmfile with a selector as @vbehar mentions if thats something helmfile can do? or we use 3 separate helmfiles maybe?&lt;/p&gt;
&lt;p&gt;e.g. the pipeline with boot apps could be something like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step helmfile --selector phase=pre-ingress

# populate ingress stuff (e.g. default domain from nip.io if not using custom domain)
jx step create install values

# add any charts that need a domain injected
jx step helmfile --selector phase=post-ingress


# populate any missing charts in vault
jx step create values --name parameters

# lets include generated secrets after they have been populated in vault
jx step helmfile --selector &amp;quot;!phase&amp;quot; --secrets
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we could have a list of apps which we group as to where they get added based on what they are &amp;amp; whether they need integration with secrets / TLS / domain / certs etc?&lt;/p&gt;
&lt;p&gt;We can then modify the existing &lt;code&gt;jx add app / jx delete app&lt;/code&gt; to detect the &lt;code&gt;apps.yaml&lt;/code&gt; file and create the necessary code change in a Pull Request.&lt;/p&gt;
&lt;p&gt;Maybe over time we move more towards this kind of helmfile-like approach for all environments too (&lt;code&gt;Dev&lt;/code&gt; / &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt;)?&lt;/p&gt;
&lt;h3 id=&#34;proposed-schedule&#34;&gt;Proposed Schedule&lt;/h3&gt;
&lt;p&gt;We can easily try a prototype a new boot config repo where we add helmfile and add some helmfile steps and see how it works and what we think of the general git source code &amp;amp; if it helps us and users have modular boot apps without committing to any significant changes in the jx repos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try out helmfile for installing things like gloo / knative / linkerd / istio?&lt;/li&gt;
&lt;li&gt;if that works and we are happy with it, we could look at adding the phases approach for easier app composition&lt;/li&gt;
&lt;li&gt;if thats all looking good try migrate existing things like nginx / cert manager / external dns to the helmfile approach in a new git repository&lt;/li&gt;
&lt;li&gt;anyone can then try out the helmfile approach without changing the core upstream boot configuration &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/tree/master/env&#34;&gt;jenkins-x-boot-config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;we could try create a new remote cluster boot configuration for multi-cluster which installs a small subset of Jenkins X (e.g. lighthouse + tekton + a single &lt;code&gt;SourceRepository + Schedule&lt;/code&gt; for replicating the logic of the &lt;code&gt;environment controller&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;create a demo repository which replaces nginx-controller with knative + gloo we can use for Progressive Delivery demos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maybe we find when we look at migrating the current charts to boot apps (nginx / cert manager / external-dns in particular) we may find its got some limitations and building a simple similar tool might be easier. Or we may find helmfile gets us where we need to go faster.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: How it works</title>
      <link>/docs/labs/boot/how-it-works/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/how-it-works/</guid>
      <description>
        
        
        &lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;The git repository for the (development) environment git repository looks like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx-requirements.yml   # the configuration of cluster, environments, storage, ingress etc
jx-apps.yml           # the list of apps to be installed
jenkins-x.yml         # the Jenkins X Pipeline to boot up Jenkins X
apps/
system/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We use the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file as source to generate 2 &lt;code&gt;helmfile.yaml&lt;/code&gt; files to perform the installation. This is done by the &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; command.&lt;/p&gt;
&lt;p&gt;After this command is run the git repository file system looks like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apps/
  helmfile.yaml
system/
  helmfile.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then the pipeline is effectively this (slightly simplifying for clarity):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step verify preinstall
jx step create helmfile
cd system &amp;amp;&amp;amp; helmfile sync
jx step verify ingress
cd apps &amp;amp;&amp;amp; helmfile sync
jx step verify env
jx step verify install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So the pipeline is very similar to the traditional helm 2 boot pipeline. The main differences is the change to &lt;code&gt;helmfile sync&lt;/code&gt; to apply all the helm charts at the &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;apps&lt;/code&gt; phase. Also the helm 2 pipeline has lots of steps related to installing specific individual charts (nginx/velero/cert-manager/externaldns) - with the helmfile solution thats all done by the &lt;code&gt;jx-apps.yml&lt;/code&gt; file so we don&amp;rsquo;t need to touch the &lt;code&gt;jenkins-x.yml&lt;/code&gt; pipeline at all if we want to add/remove any apps.&lt;/p&gt;
&lt;h3 id=&#34;how-the-helmfileyaml-generation-works&#34;&gt;How the helmfile.yaml generation works&lt;/h3&gt;
&lt;p&gt;This is all done by the &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; command if you want to look at the code. Essentially we take that YAML file and parse it and use it to generate one of the helmfiles: &lt;code&gt;system/helmfile.yaml&lt;/code&gt; for system charts (installed before ingress, DNS, TLS and certs are setup and the domain is known) and any other charts in &lt;code&gt;apps/helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;defaulting-configuration&#34;&gt;Defaulting configuration&lt;/h4&gt;
&lt;p&gt;In an effort to try streamline the users boot configuration repository, we&amp;rsquo;ve tried to put as much common configuration into the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; as possible.&lt;/p&gt;
&lt;p&gt;For example the default &lt;code&gt;namespace&lt;/code&gt; for a chart and the &lt;code&gt;phase&lt;/code&gt; (whether its installed via the &lt;code&gt;system&lt;/code&gt; helmfile or the default &lt;code&gt;apps&lt;/code&gt; helmfile) can be specified in the &lt;code&gt;defaults.yml&lt;/code&gt; file in the version stream. e.g. here&amp;rsquo;s where we define the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/stable/nginx-ingress/defaults.yml&#34;&gt;apps/stable/nginx-ingress/defaults.yml&lt;/a&gt; for &lt;code&gt;nginx-ingress&lt;/code&gt;. This keeps the actual &lt;code&gt;jx-apps.yml&lt;/code&gt; nice and simple&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/nginx-ingress
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Though if you really want you can be completely specific in your &lt;code&gt;jx-apps.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: nginx
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;valuesyaml-files&#34;&gt;values.yaml* files&lt;/h4&gt;
&lt;p&gt;In boot with helm 2 you can specify custom &lt;code&gt;values.yaml&lt;/code&gt; files or &lt;code&gt;values.tmpl.yaml&lt;/code&gt; (using go templates) files in a folder named after the chart in the &lt;code&gt;env&lt;/code&gt; folder in the git repository. e.g. here&amp;rsquo;s the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/tekton/values.tmpl.yaml&#34;&gt;env/tekton/values.tmpl.yaml&lt;/a&gt; file to customise tekton to the Jenkins X requirements and secrets.&lt;/p&gt;
&lt;p&gt;We use a similar approach of using &lt;code&gt;values.yaml&lt;/code&gt; files or templates - which in helmfile are called &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; instead - which can be put in a folder named after the chart.&lt;/p&gt;
&lt;p&gt;So to do something similar in helmfile and helm 3 you could create an &lt;code&gt;apps/tekton/values.yaml.gotmpl&lt;/code&gt; file and it will be automatically picked up by &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; and referenced in the generated &lt;code&gt;apps/helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However usually these &lt;code&gt;values.yaml*&lt;/code&gt; files we write for each chart are bindings to the &lt;code&gt;jx-requirements.yml&lt;/code&gt; and secrets and they usually don&amp;rsquo;t change between cluster installations.&lt;/p&gt;
&lt;p&gt;So we&amp;rsquo;ve allowed these files to be stored in the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; instead. e.g. here&amp;rsquo;s the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/tekton/values.yaml.gotmpl&#34;&gt;apps/jenkins-x/tekton/values.yaml.gotmpl&lt;/a&gt; file to customise the &lt;code&gt;tekton&lt;/code&gt; chart for use in Jenkins X with helmfile and helm 3.&lt;/p&gt;
&lt;p&gt;This helps keep the git repository for your (dev) environment much smaller and easier to manage. You can still override the &lt;code&gt;values.yaml*&lt;/code&gt; files for any app if you want inside your boot config git repository though..&lt;/p&gt;
&lt;h3 id=&#34;passing-in-jx-requirementsyml-and-secrets&#34;&gt;Passing in jx-requirements.yml and secrets&lt;/h3&gt;
&lt;p&gt;In boot with helm 2 we used &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/boot/how-it-works/#values-tmpl-yaml-templates&#34;&gt;some custom values in the values.yaml.tmpl files&lt;/a&gt; to inject values from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; and secrets.&lt;/p&gt;
&lt;p&gt;To make it easier to use helmfile and helm 3 easily without any custom modifications we&amp;rsquo;ve used a slightly different approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we turn the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file into a vanilla YAML file with the top level key &lt;code&gt;jxRequirements&lt;/code&gt; - the file is generated by the boot pipeline called &lt;code&gt;jx-requirements.values.yaml.gotmpl&lt;/code&gt; and referenced in the generated helmfiles. This means instead of expressions like &lt;code&gt;{{ .Requirements.cluster.provider }}&lt;/code&gt; you can use the vanilla helm expression of &lt;code&gt;{{ .Values.jxRequirements.cluster.provider }}&lt;/code&gt; in any &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; you use in helmfile like in the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/jenkins-x/tekton/values.yaml.gotmpl#L8&#34;&gt;tekton values.yaml.gotmpl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;we put all secrets in a file called &lt;code&gt;secrets.yaml&lt;/code&gt; with a top level key of &lt;code&gt;secrets&lt;/code&gt; referenced by &lt;code&gt;$JX_SECRETS_DIR/secrets.yaml&lt;/code&gt;. This means we can change any old boot expressions of &lt;code&gt;{{ .Parameters.pipelineUser.token }}&lt;/code&gt; to the canonical helm expression &lt;code&gt;{{ .Values.secrets.pipelineUser.token }}&lt;/code&gt; like in this &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/jenkins-x/tekton/values.yaml.gotmpl#L7&#34;&gt;tekton values.yaml.gotmpl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FAQ</title>
      <link>/docs/labs/boot/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/faq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;how-do-i-list-the-apps-that-have-been-deployed&#34;&gt;How do I list the apps that have been deployed?&lt;/h2&gt;
&lt;p&gt;You can use helm 3.x directly to list all the apps (charts) deployed in a namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To look in another namespace add it as an argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm list -n nginx
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;how-do-i-customise-an-app-in-an-environment&#34;&gt;How do I customise an App in an Environment&lt;/h2&gt;
&lt;p&gt;With the new helm 3 based boot every environment uses boot - so there is a single way to configure anything whether its in the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment and whether or not you are using &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multiple clusters&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;how to customise a chart&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;How do I configure the ingress domain in Dev, Staging or Production?&lt;/h2&gt;
&lt;p&gt;With the new helm 3 based boot every environment uses boot - so there is a single way to configure anything whether its in the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment and whether or not you are using &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multiple clusters&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can override the domain name for use in all apps within an environment by modifying the &lt;code&gt;jx-requirements.yml&lt;/code&gt; in the git repository for the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also by default there is a namespace specific separator added. So if your service is &lt;code&gt;cheese&lt;/code&gt; the full domain name would be something like &lt;code&gt;cheese.jx-staging.mydomain.com&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you wish to avoid the namespace specific separator if each environment already has its own unique &lt;code&gt;domain&lt;/code&gt; value then you can specify:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespaceSubDomain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you wish to change any of these values for a single app only then you can use the &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;app customisation mechanism&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;e.g. for an app called &lt;code&gt;mychart&lt;/code&gt; you can create a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; in the git repository for your environment and add the following YAML:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;jxRequirements&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com  
    &lt;span style=&#34;color:#66d9ef&#34;&gt;namespaceSubDomain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;how-do-i-configure-the-ingress-tls-certificate-in-dev-staging-or-production&#34;&gt;How do I configure the ingress TLS certificate in Dev, Staging or Production?&lt;/h2&gt;
&lt;p&gt;You can specify the TLS certificate to use for the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment by modifying the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in the environments git repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;: 
  &lt;span style=&#34;color:#66d9ef&#34;&gt;tls&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;secretName&lt;/span&gt;: my-tls-secret-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will then be applied to all the Jenkins X ingress resources for things like &lt;code&gt;lighthouse&lt;/code&gt; or &lt;code&gt;nexus&lt;/code&gt; - plus any apps you deploy to &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you want to override the TLS secret name for a specific app in a specific environment then rather like the &lt;a href=&#34;#how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;above question&lt;/a&gt; you can use the &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;app customisation mechanism&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;e.g. for an app called &lt;code&gt;mychart&lt;/code&gt; you can create a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; in the git repository for your environment and add the following YAML:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;jxRequirements&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;tls&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;secretName&lt;/span&gt;: my-tls-secret-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;how-do-i-uninstall-boot&#34;&gt;How do I uninstall boot?&lt;/h2&gt;
&lt;p&gt;From inside a git clone of your &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment&amp;rsquo;s git repository you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step create helmfile 
helmfile destroy
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
